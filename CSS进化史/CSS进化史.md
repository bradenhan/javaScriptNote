# 浅谈CSS发展

## 什么是CSS
层叠样式表 (Cascading Style Sheets，缩写为 CSS）， 是一种 样式表 语言，用来描述 HTML 或 XML（包括如 SVG、XHTML 之类的 XML 分支语言）文档的呈现。CSS 描述了在`屏幕、纸质、音频等`其它媒体上的元素应该如何被渲染的问题。

## CSS发展历程

![](https://mdn.mozillademos.org/files/3623/CSS_Modules_and_Snapshots.png)

### 1.1996年12月—CSS 1
互联网上对CSS正式的介绍要追溯到1996年，万维网联盟 (W3C) 面向全世界发布CSS的时候。

“HTML 是一种具有语义并用来传达网页内容的语言，CSS 最初的设计目的，就是为了使 HTML 的这一理念能够保持下去。”一位Google的规范黑客（spec hacker）Tab Atkins Jr.在网络播客平台说，“尤其是让机器能够理解。

样式表并不是全新的，自从标准通用标记语言(SGML)的开发以来，它(样式表)就因为一些能力而被使用。但在当时，将它应用于网页还是很新奇的。

W3C发布的CSS推荐标准拥有以下初始属性：

 - 前景和背景颜色/图片
 - 字体属性例如字体和加粗
 - 文本，包括单词和字母间距
 - 外边距，边框，内边距
 - 分类和对齐

### 2. 1998年5月—CSS 2
参考CSS1中建立的属性，CSS 2的第一份工作草案在1997年11月发布，并且在1998年5月成为了W3C的推荐标准。

这个版本拓展了属性的能力，使其更加多样化。例如：有 :hover伪类和臭名昭著的文本阴影效果（现在已过时）

### 3. 2011年6月—CSS 2.1
然而，W3C不再维护CSS 2的推荐标准了。作为替代，CSS2.1在2004年推出并于2011年6月成为了W3C推荐标准。这个建立在CSS 2之上的修订版解决了CSS 2的很多bug并代替了之前的版本。

CSS 2.1提升了复杂度。它准许了父子关系的概念，让设计师和开发人员可以在一个给定元素上定义多个类名。它还推出了可能成为响应式设计的第一次尝试：字体大小调整(font-size-adjust)属性。

演示文稿现在可以针对特定的媒体设备，包括手持设备，盲文设备，可视化浏览器，打印机和听觉设备。这是演变成为CSS 3的开始。

### 4. CSS 3
我们现在最熟悉的版本，CSS 3开发自1999年。其最大的不同之处是引入了模块，每个模块都拥有自己的功能和扩展功能。其中有一些取代了从前CSS2.1的部分。

从形式上来说，CSS3 标准自身已经不存在了。每个模块都被独立的标准化，现在标准 CSS 包括了修订后的 CSS2.1 以及完整模块对它的扩充，模块的 level（级别）数并不一致。可以在每个时间点上为 CSS 标准定义一个 snapshots（快照），列出 CSS 2.1 和成熟的模块。
正式推荐的模块包括：

 - 2011年6月 —颜色
 - 2011年9月  第三代选择器
 - 2011年9月   命名空间
 - 2012年5月    媒体查询

媒体查询大概是最具革命性的模块之一。它负责响应式设计，并且已经成为如今网络界的标准。

### 5. CSS 的未来：它将何去何从？
很多人想知道CSS接下来会如何。一些人甚至怀疑我们是否还需要CSS。

正如很多人所注意到的，W3C已经放弃了CSS的级别，使用这些条目只是为了与从前的版本区别开来。这在W3C社区已经为人熟知了一段时间了。

“从来就没有过CSS 4，以后也永远都不会有CSS 4，CSS 4是一个不存在的东西，” Tab Atkins Jr. 于2013年在他的博客中写道。他在Google工作，坐在CSS工作组，也贡献于W3C的其他几个工作组。

现今，这种语言被简单地称为CSS。这个社区也把精力集中在开发更复杂更有益的独立模块上，使这种语言更加成熟，能够适应现在设计师和不同设备的挑战和需求。

## css主要模块
- 选择器（id、class、相邻选择器、父子选择器）
- 修饰（字体、背景、间距、对齐、边框、阴影、透明等）
- 布局（浮动、定位、弹性盒模型、网格）
- 媒体查询
- 动画等

## 模块化CSS/提升CSS提升体验
到目前为止，我们介绍了CSS的基本发展历程，现在我们再来看下那些帮助CSS提升语言本身体验的工具，先从CSS预处理器开始吧。

### 1.使用CSS预处理器扩展CSS语法
CSS预处理器允许你使用不同的语言来定义样式，最终会帮你转换为浏览器可以解释的CSS，这一点在当今浏览器对新特性支持缓慢的情况下很有价值。

主流的CSS预编译器就这三种（Sass，Less，Stylus），他们在功能方面非常相似，所以你不必担心选择哪一个会是错误的。

- 第一个主流的CSS预处理器是2006年发布的Sass，它提供了一个新的更简洁的语法（缩进代替大括号，没有分号等等），同时增加了一些CSS缺失的高级特性，像变量、工具方法还有计算。

      $dark-color: #4a4a4a
      $light-color: #f9f9f9
      $side-color: #eee
      body
        color: $dark-color
      header, footer
        background-color: $dark-color
        color: $light-color
      main
        background: $light-color
      nav, aside
        background: $side-color
  注意我们`用$定义了可复用的变量，省略了大括号和分号`，语法看起来更加清晰了。简洁的语法让Sass看起来很棒，但变量这样的特性出现在当时来说意义更大，这为编写整洁可维护的CSS代码开辟了新的可能性。

- 第二个主流的CSS预处理器是2009年发布的Less CSS预编译器。

  它也是Ruby写的，并且提供了类似于Sass的功能，关键不同点是它的语法设计上更接近CSS。这意味着任何CSS代码都是合法的Less代码，同样我们看一个用Less语法的例子：

      @dark-color:#4a4a4a;
      @light-color:#f9f9f9;
      @side-color:#eee;
      body {
        color: @dark-color;
      }
      header, footer {
        background-color: @dark-color;
        color: @light-color;
      }
      main {
        background: @light-color;
      }
      nav, aside {
        background: @side-color;
      }

  语法上几乎是相同的（变量的定义使用@替代了$），但是Less和CSS一样带有大括号和分号，没有Sass例子的代码看起来漂亮。然而，和CSS相近的特性反而让开发者更容易接受它，在2012年，Less使用了JavaScript（Node.js）重写了替换了Ruby，性能上比Ruby编译更快了，并且很多在工作中使用了Node.js的人更容易上手了。

-  第三个主流的CSS预处理器是 --- Sass开发者在2010年发布了一个新的语法叫SCSS（与Less类似的一个CSS超集），同时发布了LibSass，一个基于C++扩展的Ruby引擎，让编译更快并且适配于多种语言。

- 第四个主流的CSS预处理器是2010年发布的Stylus，使用Node.js编写，和Sass或者Less相比更注重于清晰的语法。通常主流的CSS预编译器就这三种（Sass，Less，Stylus），他们在功能方面非常相似，所以你不必担心选择哪一个会是错误的。

### 2. 自动补全不同浏览器之间的厂商前缀
厂商前缀是浏览器厂商对CSS新功能的实验和测试使用的，在正式实现前提供给开发者使用CSS新属性的一种方式。-ms代表IE浏览器，-moz是火狐浏览器，-webkit是基于webkit内核的浏览器。

**解决方案：`PostCSS 和 autoprefixer 插件`**

**其他插件**

  - cssnext 插件可以让你体验下一些实验性质的CSS新功能，
  - CSS modules 可以自动改变class的名字避免名称冲突，
  - stylelint 能检查出你CSS代码中一些定义错误和不符合规范的写法。

### 3. 使用CSS设计模式
CSS预处理器和CSS后处理器让CSS开发体验有了巨大的提升，但是单靠这些工具还不足以解决维护大型项目CSS代码的问题。为了解决这个问题，人们编写了一些关于如何写CSS的指导方针，通常被称为CSS规范。

在我们深入分析CSS规范前，首先要搞清楚是什么让CSS随着时间推移变得更加难维护，关键点是CSS是全局性的——你定义的每个样式都会全局应用到页面的每个部分，用一个命名约定来保证class名称的唯一性或者有特殊的规则来决定指定样式应用到指定元素。CSS规范提供了一个有组织性的方式来避免大量代码时出现的这些问题，让我们按照时间顺序来看看主流的一些规范吧

- **OOCSS** -- OOCSS（面向对象的CSS）是在2009年首次提出的，它是围绕两个原则建立的规范。
  - 结构和样式分离
  - 容器和内容分离

  OOCSS提供了成熟的指导规范，但是对于具体的执行规范并没有明确指出。后来出现的SMACSS采用了它的核心概念，并且添加了更多的细节，使用起来更简单了。

- **SMACSS** --（可扩展模块化架构的CSS）是在2011年出现的一种设计模式，它将CSS分为5个不同的类别
  - 基本规范、
  - 布局规范、
  - 模块、
  - 状态规范
  - 样式规范

  相比OOCSS，SMACSS有了更多细节上的规范，但是CSS规则该划分为哪一类别的规范中，这是个需要仔细考虑的问题。后来出现的BEM对这一方面进行了改进，让它更易使用了。
- **BEM** -- BEM (块, 元素, 修饰符)是在2010年出现的规范，它的思想主要是围绕把用户界面切分成独立的块。

  **命名约定的模式如下：**

      .block{}
      .block__element{}
      .block--modifier{}

      例如：
      .site-search{} /* 块 */
      .site-search__field{} /* 元素 */
      .site-search--full{} /* 修饰符 */

    BEM的规范很容易理解，对于新手来说命名规则上也很友好，缺点就是可能会导致class名字非常长，并且没有遵循传统的命名规范。后来出现的Atomic CSS又把这个非传统方式带到了一个新的高度。

- **Atomic CSS** -- Atomic CSS (也称为 功能性CSS)是2014年出现的一个规范，它的思想是基于可视化的方法创建小而功能单一化的class。这种规范与OOCSS、SMACSS和BEM完全相反——它并不是把页面上的元素看做是可重用的对象，Atomic CSS忽略掉了这些对象，每一个元素使用了可重用的单一功能的class样式集合。因此像`<button class="search-form__button">Search</button>`就被替换成这样的写法了`<button class="f6 br3 ph3 pv2 white bg-purple hover-bg-light-purple">Search</button>`

  关于这个有争议的规范在不同场景下的应用也产出了一系列精彩的讨论。这篇文章很清晰的分析了传统的分离思想是CSS依赖于HTML创建（即使使用像BEM这类的规范），而Atomic的方式是HTML依赖于CSS创建，两者都没错，但是仔细想想你会发现CSS和HTML彻底分离的想法是实现不了的。

  其他的CSS设计模式，像CSS in JS其实也包含了CSS和HTML相互依赖的思想，这也成为了一个饱受争议的设计规范之一。

- **CSS in JS** -- CSS in JS 是2014年推出的一种设计模式，它的核心思想是把CSS直接写到各自组件中，而不是单独的样式文件里。这种方式在React框架中引入的，最早是使用内联样式，后来又进化成了使用JavaScript生成CSS然后插入到页面的style标签中的方式。

  CSS in JS再一次违背了CSS中关于分离的最佳实践，主要原因是web随着时间推移发生了很大的变化。最初web大部分都是静态网站——这种情况下HTML内容和CSS表现分离是很有意义的，但现在大部分应用都是动态web构建——这种情况下可重用的组件更加有意义了。

  CSS in JS设计的目标是定义边界清晰包含自己HTML/CSS/JS的独立组件，并且不受其他组件的影响。React是最早采用这种思想的框架，后续也影响到了其他框架像Angular、Ember和Vue.js。需要注意的是CSS in JS的模式相对来说比较新的，开发人员正在不断的尝试开发web应用组件时的一些CSS最佳实践。

  五花八门的设计模式很容易让你不知所措，最重要的记住一点——没有银弹。

## 结论
  - 随着互联网的不断变化，CSS发生了很大的变化，逐步向着模块化发展。
  - 对于CSS的厂商前缀问题，建议使用插件解决，利用gulp、grunt或者webpack很容易解决这个问题。
  - CSS预处理器，建议采用LESS，使用简单、语法也便于识别，仅个人建议。
  - CSS设计模式，建议采用BEM，配合[Emmet](https://emmet.io/),能有如虎添翼的感觉。
  

## 参考资料
- [CSS - MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS)
- [【第1195期】现代CSS进化史](https://mp.weixin.qq.com/s/LixbmPT8m3JcrrXfMKh-UA)
- [前端工程师应该了解的 CSS 进化史](http://blog.sina.com.cn/s/blog_e98e2a8e0102wmud.html)
- [BEM思想之彻底弄清BEM语法](https://www.w3cplus.com/css/mindbemding-getting-your-head-round-bem-syntax.html)
